# Project Name: Data Warehouse and Analytics - Star Schema Design Documentation

## Section 1: Schema Overview

### FACT TABLE: fact_sales
* **Grain:** One row per product per order line item
* **Business Process:** Sales transactions

**Measures (Numeric Facts):**
* `quantity_sold`: Number of units sold
* `unit_price`: Price per unit at time of sale
* `discount_amount`: Discount applied
* `total_amount`: Final amount (quantity × unit_price - discount)

**Foreign Keys:**
* `date_key` → dim_date
* `product_key` → dim_product
* `customer_key` → dim_customer

### DIMENSION TABLE: dim_date
* **Purpose:** Date dimension for time-based analysis
* **Type:** Conformed dimension
* **Attributes:**
    * `date_key` (PK): Surrogate key (integer, format: YYYYMMDD)
    * `full_date`: Actual date
    * `day_of_week`: Monday, Tuesday, etc.
    * `month`: 1-12
    * `month_name`: January, February, etc.
    * `quarter`: Q1, Q2, Q3, Q4
    * `year`: 2023, 2024, etc.
    * `is_weekend`: Boolean

### DIMENSION TABLE: dim_product
* **Purpose:** To filter and group sales by product details
* **Attributes:**
    * `product_key` (PK): Surrogate key (integer, auto-increment)
    * `product_id`: Natural key from source system
    * `product_name`: Name of the item (e.g., "Gaming Laptop")
    * `category`: Product category (e.g., "Electronics")
    * `brand`: Manufacturer brand
    * `current_unit_price`: Current list price

### DIMENSION TABLE: dim_customer
* **Purpose:** To analyze who is buying products
* **Attributes:**
    * `customer_key` (PK): Surrogate key (integer, auto-increment)
    * `customer_id`: Natural key from source system
    * `customer_name`: Full name of the customer
    * `email`: Customer email address
    * `city`: City (e.g., "Mumbai", "Indore")
    * `state`: State
    * `country`: Country

    ## Section 2: Design Decisions

**1. Granularity: Transaction Line-Item Level**
* **Decision:** We chose the lowest level of detail (one row per specific item in an order) rather than one row per total order.
* **Reason:** This allows FlexiMart to analyze exactly which products are selling well. If we only stored the "Order Total," we wouldn't know if the customer bought 1 expensive laptop or 50 cheap mouses.

**2. Surrogate Keys vs. Natural Keys**
* **Decision:** We use internal integers (e.g., `101`) generated by the warehouse (`date_key`, `product_key`) instead of using the original IDs from the sales software.
* **Reason:**
    * **Performance:** Computers join tables faster using simple numbers than complex text strings.
    * **Stability:** If the source system changes its ID format in the future, our data warehouse history remains safe and doesn't break.

**3. Drill-Down and Roll-Up Support**
* **Roll-Up (Summarizing):** The `dim_date` hierarchy (Day → Month → Quarter → Year) allows managers to easily "zoom out" from daily sales to see quarterly trends.
* **Drill-Down (Detailing):** The `dim_product` hierarchy allows us to start with "Category" sales (e.g., Electronics) and "zoom in" to see which specific "Brand" or "Product Name" is driving that revenue.


## Section 3: Sample Data Flow

**Source Transaction (Raw Data):**
> Order #101 | Date: 2024-01-15 | Customer: "John Doe" | Product: "Laptop" | Qty: 2 | Price: 50,000

**Data Warehouse Transformation:**

**1. The Dimensions (The Context):**
* **dim_date:** `{ date_key: 20240115, full_date: '2024-01-15', month: 1, quarter: 'Q1' ... }`
* **dim_product:** `{ product_key: 5, product_name: 'Laptop', category: 'Electronics' ... }`
* **dim_customer:** `{ customer_key: 12, customer_name: 'John Doe', city: 'Mumbai' ... }`

**2. The Fact Table (The Metric):**
* **fact_sales:**
    ```json
    {
      "date_key": 20240115,
      "product_key": 5,
      "customer_key": 12,
      "quantity_sold": 2,
      "unit_price": 50000,
      "total_amount": 100000
    }
    ```